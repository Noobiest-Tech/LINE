#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def approveChannelAndIssueChannelToken(self, channelId):
        """
        Parameters:
         - channelId

        """
        pass

    def getReturnUrlWithRequestTokenForAutoLogin(self, webLoginRequest):
        """
        Parameters:
         - webLoginRequest

        """
        pass

    def getChannelInfo(self, channelId, locale):
        """
        Parameters:
         - channelId
         - locale

        """
        pass

    def issueRequestTokenWithAuthScheme(self, channelId, otpId, authScheme, returnUrl):
        """
        Parameters:
         - channelId
         - otpId
         - authScheme
         - returnUrl

        """
        pass

    def getApprovedChannels(self, lastSynced, locale):
        """
        Parameters:
         - lastSynced
         - locale

        """
        pass

    def reserveCoinUse(self, request, locale):
        """
        Parameters:
         - request
         - locale

        """
        pass

    def getCommonDomains(self, lastSynced):
        """
        Parameters:
         - lastSynced

        """
        pass

    def getUpdatedChannelIds(self, channelIds):
        """
        Parameters:
         - channelIds

        """
        pass

    def issueChannelToken(self, channelId):
        """
        Parameters:
         - channelId

        """
        pass

    def getWebLoginDisallowedUrl(self, webLoginRequest):
        """
        Parameters:
         - webLoginRequest

        """
        pass

    def getChannelNotificationSettings(self, locale):
        """
        Parameters:
         - locale

        """
        pass

    def updateChannelNotificationSetting(self, setting):
        """
        Parameters:
         - setting

        """
        pass

    def revokeChannel(self, channelId):
        """
        Parameters:
         - channelId

        """
        pass

    def getChannelSettings(self):
        pass

    def updateChannelSettings(self, channelSettings):
        """
        Parameters:
         - channelSettings

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def approveChannelAndIssueChannelToken(self, channelId):
        """
        Parameters:
         - channelId

        """
        self.send_approveChannelAndIssueChannelToken(channelId)
        return self.recv_approveChannelAndIssueChannelToken()

    def send_approveChannelAndIssueChannelToken(self, channelId):
        self._oprot.writeMessageBegin('approveChannelAndIssueChannelToken', TMessageType.CALL, self._seqid)
        args = approveChannelAndIssueChannelToken_args()
        args.channelId = channelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_approveChannelAndIssueChannelToken(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = approveChannelAndIssueChannelToken_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "approveChannelAndIssueChannelToken failed: unknown result")

    def getReturnUrlWithRequestTokenForAutoLogin(self, webLoginRequest):
        """
        Parameters:
         - webLoginRequest

        """
        self.send_getReturnUrlWithRequestTokenForAutoLogin(webLoginRequest)
        return self.recv_getReturnUrlWithRequestTokenForAutoLogin()

    def send_getReturnUrlWithRequestTokenForAutoLogin(self, webLoginRequest):
        self._oprot.writeMessageBegin('getReturnUrlWithRequestTokenForAutoLogin', TMessageType.CALL, self._seqid)
        args = getReturnUrlWithRequestTokenForAutoLogin_args()
        args.webLoginRequest = webLoginRequest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getReturnUrlWithRequestTokenForAutoLogin(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getReturnUrlWithRequestTokenForAutoLogin_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getReturnUrlWithRequestTokenForAutoLogin failed: unknown result")

    def getChannelInfo(self, channelId, locale):
        """
        Parameters:
         - channelId
         - locale

        """
        self.send_getChannelInfo(channelId, locale)
        return self.recv_getChannelInfo()

    def send_getChannelInfo(self, channelId, locale):
        self._oprot.writeMessageBegin('getChannelInfo', TMessageType.CALL, self._seqid)
        args = getChannelInfo_args()
        args.channelId = channelId
        args.locale = locale
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getChannelInfo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getChannelInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getChannelInfo failed: unknown result")

    def issueRequestTokenWithAuthScheme(self, channelId, otpId, authScheme, returnUrl):
        """
        Parameters:
         - channelId
         - otpId
         - authScheme
         - returnUrl

        """
        self.send_issueRequestTokenWithAuthScheme(channelId, otpId, authScheme, returnUrl)
        return self.recv_issueRequestTokenWithAuthScheme()

    def send_issueRequestTokenWithAuthScheme(self, channelId, otpId, authScheme, returnUrl):
        self._oprot.writeMessageBegin('issueRequestTokenWithAuthScheme', TMessageType.CALL, self._seqid)
        args = issueRequestTokenWithAuthScheme_args()
        args.channelId = channelId
        args.otpId = otpId
        args.authScheme = authScheme
        args.returnUrl = returnUrl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_issueRequestTokenWithAuthScheme(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = issueRequestTokenWithAuthScheme_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "issueRequestTokenWithAuthScheme failed: unknown result")

    def getApprovedChannels(self, lastSynced, locale):
        """
        Parameters:
         - lastSynced
         - locale

        """
        self.send_getApprovedChannels(lastSynced, locale)
        return self.recv_getApprovedChannels()

    def send_getApprovedChannels(self, lastSynced, locale):
        self._oprot.writeMessageBegin('getApprovedChannels', TMessageType.CALL, self._seqid)
        args = getApprovedChannels_args()
        args.lastSynced = lastSynced
        args.locale = locale
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getApprovedChannels(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getApprovedChannels_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getApprovedChannels failed: unknown result")

    def reserveCoinUse(self, request, locale):
        """
        Parameters:
         - request
         - locale

        """
        self.send_reserveCoinUse(request, locale)
        return self.recv_reserveCoinUse()

    def send_reserveCoinUse(self, request, locale):
        self._oprot.writeMessageBegin('reserveCoinUse', TMessageType.CALL, self._seqid)
        args = reserveCoinUse_args()
        args.request = request
        args.locale = locale
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reserveCoinUse(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reserveCoinUse_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "reserveCoinUse failed: unknown result")

    def getCommonDomains(self, lastSynced):
        """
        Parameters:
         - lastSynced

        """
        self.send_getCommonDomains(lastSynced)
        return self.recv_getCommonDomains()

    def send_getCommonDomains(self, lastSynced):
        self._oprot.writeMessageBegin('getCommonDomains', TMessageType.CALL, self._seqid)
        args = getCommonDomains_args()
        args.lastSynced = lastSynced
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCommonDomains(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCommonDomains_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCommonDomains failed: unknown result")

    def getUpdatedChannelIds(self, channelIds):
        """
        Parameters:
         - channelIds

        """
        self.send_getUpdatedChannelIds(channelIds)
        return self.recv_getUpdatedChannelIds()

    def send_getUpdatedChannelIds(self, channelIds):
        self._oprot.writeMessageBegin('getUpdatedChannelIds', TMessageType.CALL, self._seqid)
        args = getUpdatedChannelIds_args()
        args.channelIds = channelIds
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getUpdatedChannelIds(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getUpdatedChannelIds_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getUpdatedChannelIds failed: unknown result")

    def issueChannelToken(self, channelId):
        """
        Parameters:
         - channelId

        """
        self.send_issueChannelToken(channelId)
        return self.recv_issueChannelToken()

    def send_issueChannelToken(self, channelId):
        self._oprot.writeMessageBegin('issueChannelToken', TMessageType.CALL, self._seqid)
        args = issueChannelToken_args()
        args.channelId = channelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_issueChannelToken(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = issueChannelToken_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "issueChannelToken failed: unknown result")

    def getWebLoginDisallowedUrl(self, webLoginRequest):
        """
        Parameters:
         - webLoginRequest

        """
        self.send_getWebLoginDisallowedUrl(webLoginRequest)
        return self.recv_getWebLoginDisallowedUrl()

    def send_getWebLoginDisallowedUrl(self, webLoginRequest):
        self._oprot.writeMessageBegin('getWebLoginDisallowedUrl', TMessageType.CALL, self._seqid)
        args = getWebLoginDisallowedUrl_args()
        args.webLoginRequest = webLoginRequest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getWebLoginDisallowedUrl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getWebLoginDisallowedUrl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getWebLoginDisallowedUrl failed: unknown result")

    def getChannelNotificationSettings(self, locale):
        """
        Parameters:
         - locale

        """
        self.send_getChannelNotificationSettings(locale)
        return self.recv_getChannelNotificationSettings()

    def send_getChannelNotificationSettings(self, locale):
        self._oprot.writeMessageBegin('getChannelNotificationSettings', TMessageType.CALL, self._seqid)
        args = getChannelNotificationSettings_args()
        args.locale = locale
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getChannelNotificationSettings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getChannelNotificationSettings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getChannelNotificationSettings failed: unknown result")

    def updateChannelNotificationSetting(self, setting):
        """
        Parameters:
         - setting

        """
        self.send_updateChannelNotificationSetting(setting)
        self.recv_updateChannelNotificationSetting()

    def send_updateChannelNotificationSetting(self, setting):
        self._oprot.writeMessageBegin('updateChannelNotificationSetting', TMessageType.CALL, self._seqid)
        args = updateChannelNotificationSetting_args()
        args.setting = setting
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateChannelNotificationSetting(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateChannelNotificationSetting_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def revokeChannel(self, channelId):
        """
        Parameters:
         - channelId

        """
        self.send_revokeChannel(channelId)
        self.recv_revokeChannel()

    def send_revokeChannel(self, channelId):
        self._oprot.writeMessageBegin('revokeChannel', TMessageType.CALL, self._seqid)
        args = revokeChannel_args()
        args.channelId = channelId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revokeChannel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revokeChannel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def getChannelSettings(self):
        self.send_getChannelSettings()
        return self.recv_getChannelSettings()

    def send_getChannelSettings(self):
        self._oprot.writeMessageBegin('getChannelSettings', TMessageType.CALL, self._seqid)
        args = getChannelSettings_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getChannelSettings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getChannelSettings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getChannelSettings failed: unknown result")

    def updateChannelSettings(self, channelSettings):
        """
        Parameters:
         - channelSettings

        """
        self.send_updateChannelSettings(channelSettings)
        return self.recv_updateChannelSettings()

    def send_updateChannelSettings(self, channelSettings):
        self._oprot.writeMessageBegin('updateChannelSettings', TMessageType.CALL, self._seqid)
        args = updateChannelSettings_args()
        args.channelSettings = channelSettings
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateChannelSettings(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateChannelSettings_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateChannelSettings failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["approveChannelAndIssueChannelToken"] = Processor.process_approveChannelAndIssueChannelToken
        self._processMap["getReturnUrlWithRequestTokenForAutoLogin"] = Processor.process_getReturnUrlWithRequestTokenForAutoLogin
        self._processMap["getChannelInfo"] = Processor.process_getChannelInfo
        self._processMap["issueRequestTokenWithAuthScheme"] = Processor.process_issueRequestTokenWithAuthScheme
        self._processMap["getApprovedChannels"] = Processor.process_getApprovedChannels
        self._processMap["reserveCoinUse"] = Processor.process_reserveCoinUse
        self._processMap["getCommonDomains"] = Processor.process_getCommonDomains
        self._processMap["getUpdatedChannelIds"] = Processor.process_getUpdatedChannelIds
        self._processMap["issueChannelToken"] = Processor.process_issueChannelToken
        self._processMap["getWebLoginDisallowedUrl"] = Processor.process_getWebLoginDisallowedUrl
        self._processMap["getChannelNotificationSettings"] = Processor.process_getChannelNotificationSettings
        self._processMap["updateChannelNotificationSetting"] = Processor.process_updateChannelNotificationSetting
        self._processMap["revokeChannel"] = Processor.process_revokeChannel
        self._processMap["getChannelSettings"] = Processor.process_getChannelSettings
        self._processMap["updateChannelSettings"] = Processor.process_updateChannelSettings
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_approveChannelAndIssueChannelToken(self, seqid, iprot, oprot):
        args = approveChannelAndIssueChannelToken_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = approveChannelAndIssueChannelToken_result()
        try:
            result.success = self._handler.approveChannelAndIssueChannelToken(args.channelId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("approveChannelAndIssueChannelToken", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getReturnUrlWithRequestTokenForAutoLogin(self, seqid, iprot, oprot):
        args = getReturnUrlWithRequestTokenForAutoLogin_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getReturnUrlWithRequestTokenForAutoLogin_result()
        try:
            result.success = self._handler.getReturnUrlWithRequestTokenForAutoLogin(args.webLoginRequest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getReturnUrlWithRequestTokenForAutoLogin", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getChannelInfo(self, seqid, iprot, oprot):
        args = getChannelInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getChannelInfo_result()
        try:
            result.success = self._handler.getChannelInfo(args.channelId, args.locale)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getChannelInfo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_issueRequestTokenWithAuthScheme(self, seqid, iprot, oprot):
        args = issueRequestTokenWithAuthScheme_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = issueRequestTokenWithAuthScheme_result()
        try:
            result.success = self._handler.issueRequestTokenWithAuthScheme(args.channelId, args.otpId, args.authScheme, args.returnUrl)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("issueRequestTokenWithAuthScheme", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getApprovedChannels(self, seqid, iprot, oprot):
        args = getApprovedChannels_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getApprovedChannels_result()
        try:
            result.success = self._handler.getApprovedChannels(args.lastSynced, args.locale)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getApprovedChannels", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reserveCoinUse(self, seqid, iprot, oprot):
        args = reserveCoinUse_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reserveCoinUse_result()
        try:
            result.success = self._handler.reserveCoinUse(args.request, args.locale)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reserveCoinUse", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCommonDomains(self, seqid, iprot, oprot):
        args = getCommonDomains_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCommonDomains_result()
        try:
            result.success = self._handler.getCommonDomains(args.lastSynced)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCommonDomains", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getUpdatedChannelIds(self, seqid, iprot, oprot):
        args = getUpdatedChannelIds_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getUpdatedChannelIds_result()
        try:
            result.success = self._handler.getUpdatedChannelIds(args.channelIds)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getUpdatedChannelIds", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_issueChannelToken(self, seqid, iprot, oprot):
        args = issueChannelToken_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = issueChannelToken_result()
        try:
            result.success = self._handler.issueChannelToken(args.channelId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("issueChannelToken", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getWebLoginDisallowedUrl(self, seqid, iprot, oprot):
        args = getWebLoginDisallowedUrl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getWebLoginDisallowedUrl_result()
        try:
            result.success = self._handler.getWebLoginDisallowedUrl(args.webLoginRequest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getWebLoginDisallowedUrl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getChannelNotificationSettings(self, seqid, iprot, oprot):
        args = getChannelNotificationSettings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getChannelNotificationSettings_result()
        try:
            result.success = self._handler.getChannelNotificationSettings(args.locale)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getChannelNotificationSettings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateChannelNotificationSetting(self, seqid, iprot, oprot):
        args = updateChannelNotificationSetting_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateChannelNotificationSetting_result()
        try:
            self._handler.updateChannelNotificationSetting(args.setting)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateChannelNotificationSetting", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revokeChannel(self, seqid, iprot, oprot):
        args = revokeChannel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revokeChannel_result()
        try:
            self._handler.revokeChannel(args.channelId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revokeChannel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getChannelSettings(self, seqid, iprot, oprot):
        args = getChannelSettings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getChannelSettings_result()
        try:
            result.success = self._handler.getChannelSettings()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getChannelSettings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateChannelSettings(self, seqid, iprot, oprot):
        args = updateChannelSettings_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateChannelSettings_result()
        try:
            result.success = self._handler.updateChannelSettings(args.channelSettings)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ChannelException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateChannelSettings", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class approveChannelAndIssueChannelToken_args(object):
    """
    Attributes:
     - channelId

    """


    def __init__(self, channelId=None,):
        self.channelId = channelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.channelId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('approveChannelAndIssueChannelToken_args')
        if self.channelId is not None:
            oprot.writeFieldBegin('channelId', TType.STRING, 1)
            oprot.writeString(self.channelId.encode('utf-8') if sys.version_info[0] == 2 else self.channelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(approveChannelAndIssueChannelToken_args)
approveChannelAndIssueChannelToken_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'channelId', 'UTF8', None, ),  # 1
)


class approveChannelAndIssueChannelToken_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ChannelToken()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('approveChannelAndIssueChannelToken_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(approveChannelAndIssueChannelToken_result)
approveChannelAndIssueChannelToken_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ChannelToken, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class getReturnUrlWithRequestTokenForAutoLogin_args(object):
    """
    Attributes:
     - webLoginRequest

    """


    def __init__(self, webLoginRequest=None,):
        self.webLoginRequest = webLoginRequest

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.webLoginRequest = WebLoginRequest()
                    self.webLoginRequest.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReturnUrlWithRequestTokenForAutoLogin_args')
        if self.webLoginRequest is not None:
            oprot.writeFieldBegin('webLoginRequest', TType.STRUCT, 2)
            self.webLoginRequest.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReturnUrlWithRequestTokenForAutoLogin_args)
getReturnUrlWithRequestTokenForAutoLogin_args.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'webLoginRequest', [WebLoginRequest, None], None, ),  # 2
)


class getReturnUrlWithRequestTokenForAutoLogin_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WebLoginResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getReturnUrlWithRequestTokenForAutoLogin_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getReturnUrlWithRequestTokenForAutoLogin_result)
getReturnUrlWithRequestTokenForAutoLogin_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [WebLoginResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class getChannelInfo_args(object):
    """
    Attributes:
     - channelId
     - locale

    """


    def __init__(self, channelId=None, locale=None,):
        self.channelId = channelId
        self.locale = locale

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.channelId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.locale = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getChannelInfo_args')
        if self.channelId is not None:
            oprot.writeFieldBegin('channelId', TType.STRING, 2)
            oprot.writeString(self.channelId.encode('utf-8') if sys.version_info[0] == 2 else self.channelId)
            oprot.writeFieldEnd()
        if self.locale is not None:
            oprot.writeFieldBegin('locale', TType.STRING, 3)
            oprot.writeString(self.locale.encode('utf-8') if sys.version_info[0] == 2 else self.locale)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getChannelInfo_args)
getChannelInfo_args.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRING, 'channelId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'locale', 'UTF8', None, ),  # 3
)


class getChannelInfo_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ChannelInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getChannelInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getChannelInfo_result)
getChannelInfo_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ChannelInfo, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class issueRequestTokenWithAuthScheme_args(object):
    """
    Attributes:
     - channelId
     - otpId
     - authScheme
     - returnUrl

    """


    def __init__(self, channelId=None, otpId=None, authScheme=None, returnUrl=None,):
        self.channelId = channelId
        self.otpId = otpId
        self.authScheme = authScheme
        self.returnUrl = returnUrl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.channelId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.otpId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.authScheme = []
                    (_etype553, _size550) = iprot.readListBegin()
                    for _i554 in range(_size550):
                        _elem555 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.authScheme.append(_elem555)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.returnUrl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('issueRequestTokenWithAuthScheme_args')
        if self.channelId is not None:
            oprot.writeFieldBegin('channelId', TType.STRING, 1)
            oprot.writeString(self.channelId.encode('utf-8') if sys.version_info[0] == 2 else self.channelId)
            oprot.writeFieldEnd()
        if self.otpId is not None:
            oprot.writeFieldBegin('otpId', TType.STRING, 2)
            oprot.writeString(self.otpId.encode('utf-8') if sys.version_info[0] == 2 else self.otpId)
            oprot.writeFieldEnd()
        if self.authScheme is not None:
            oprot.writeFieldBegin('authScheme', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.authScheme))
            for iter556 in self.authScheme:
                oprot.writeString(iter556.encode('utf-8') if sys.version_info[0] == 2 else iter556)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.returnUrl is not None:
            oprot.writeFieldBegin('returnUrl', TType.STRING, 4)
            oprot.writeString(self.returnUrl.encode('utf-8') if sys.version_info[0] == 2 else self.returnUrl)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(issueRequestTokenWithAuthScheme_args)
issueRequestTokenWithAuthScheme_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'channelId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'otpId', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'authScheme', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'returnUrl', 'UTF8', None, ),  # 4
)


class issueRequestTokenWithAuthScheme_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RequestTokenResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('issueRequestTokenWithAuthScheme_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(issueRequestTokenWithAuthScheme_result)
issueRequestTokenWithAuthScheme_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RequestTokenResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class getApprovedChannels_args(object):
    """
    Attributes:
     - lastSynced
     - locale

    """


    def __init__(self, lastSynced=None, locale=None,):
        self.lastSynced = lastSynced
        self.locale = locale

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I64:
                    self.lastSynced = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.locale = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getApprovedChannels_args')
        if self.lastSynced is not None:
            oprot.writeFieldBegin('lastSynced', TType.I64, 2)
            oprot.writeI64(self.lastSynced)
            oprot.writeFieldEnd()
        if self.locale is not None:
            oprot.writeFieldBegin('locale', TType.STRING, 3)
            oprot.writeString(self.locale.encode('utf-8') if sys.version_info[0] == 2 else self.locale)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getApprovedChannels_args)
getApprovedChannels_args.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.I64, 'lastSynced', None, None, ),  # 2
    (3, TType.STRING, 'locale', 'UTF8', None, ),  # 3
)


class getApprovedChannels_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ApprovedChannelInfos()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getApprovedChannels_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getApprovedChannels_result)
getApprovedChannels_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ApprovedChannelInfos, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class reserveCoinUse_args(object):
    """
    Attributes:
     - request
     - locale

    """


    def __init__(self, request=None, locale=None,):
        self.request = request
        self.locale = locale

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = CoinUseReservation()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.locale = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reserveCoinUse_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        if self.locale is not None:
            oprot.writeFieldBegin('locale', TType.STRING, 3)
            oprot.writeString(self.locale.encode('utf-8') if sys.version_info[0] == 2 else self.locale)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reserveCoinUse_args)
reserveCoinUse_args.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'request', [CoinUseReservation, None], None, ),  # 2
    (3, TType.STRING, 'locale', 'UTF8', None, ),  # 3
)


class reserveCoinUse_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reserveCoinUse_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reserveCoinUse_result)
reserveCoinUse_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class getCommonDomains_args(object):
    """
    Attributes:
     - lastSynced

    """


    def __init__(self, lastSynced=None,):
        self.lastSynced = lastSynced

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.lastSynced = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCommonDomains_args')
        if self.lastSynced is not None:
            oprot.writeFieldBegin('lastSynced', TType.I64, 1)
            oprot.writeI64(self.lastSynced)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCommonDomains_args)
getCommonDomains_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'lastSynced', None, None, ),  # 1
)


class getCommonDomains_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ChannelDomains()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCommonDomains_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCommonDomains_result)
getCommonDomains_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ChannelDomains, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class getUpdatedChannelIds_args(object):
    """
    Attributes:
     - channelIds

    """


    def __init__(self, channelIds=None,):
        self.channelIds = channelIds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.channelIds = []
                    (_etype560, _size557) = iprot.readListBegin()
                    for _i561 in range(_size557):
                        _elem562 = ChannelIdWithLastUpdated()
                        _elem562.read(iprot)
                        self.channelIds.append(_elem562)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUpdatedChannelIds_args')
        if self.channelIds is not None:
            oprot.writeFieldBegin('channelIds', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.channelIds))
            for iter563 in self.channelIds:
                iter563.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUpdatedChannelIds_args)
getUpdatedChannelIds_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'channelIds', (TType.STRUCT, [ChannelIdWithLastUpdated, None], False), None, ),  # 1
)


class getUpdatedChannelIds_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype567, _size564) = iprot.readListBegin()
                    for _i568 in range(_size564):
                        _elem569 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem569)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getUpdatedChannelIds_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter570 in self.success:
                oprot.writeString(iter570.encode('utf-8') if sys.version_info[0] == 2 else iter570)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getUpdatedChannelIds_result)
getUpdatedChannelIds_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class issueChannelToken_args(object):
    """
    Attributes:
     - channelId

    """


    def __init__(self, channelId=None,):
        self.channelId = channelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.channelId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('issueChannelToken_args')
        if self.channelId is not None:
            oprot.writeFieldBegin('channelId', TType.STRING, 1)
            oprot.writeString(self.channelId.encode('utf-8') if sys.version_info[0] == 2 else self.channelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(issueChannelToken_args)
issueChannelToken_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'channelId', 'UTF8', None, ),  # 1
)


class issueChannelToken_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ChannelToken()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('issueChannelToken_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(issueChannelToken_result)
issueChannelToken_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ChannelToken, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class getWebLoginDisallowedUrl_args(object):
    """
    Attributes:
     - webLoginRequest

    """


    def __init__(self, webLoginRequest=None,):
        self.webLoginRequest = webLoginRequest

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.webLoginRequest = WebLoginRequest()
                    self.webLoginRequest.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getWebLoginDisallowedUrl_args')
        if self.webLoginRequest is not None:
            oprot.writeFieldBegin('webLoginRequest', TType.STRUCT, 2)
            self.webLoginRequest.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getWebLoginDisallowedUrl_args)
getWebLoginDisallowedUrl_args.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'webLoginRequest', [WebLoginRequest, None], None, ),  # 2
)


class getWebLoginDisallowedUrl_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WebLoginResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getWebLoginDisallowedUrl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getWebLoginDisallowedUrl_result)
getWebLoginDisallowedUrl_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [WebLoginResponse, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class getChannelNotificationSettings_args(object):
    """
    Attributes:
     - locale

    """


    def __init__(self, locale=None,):
        self.locale = locale

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.locale = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getChannelNotificationSettings_args')
        if self.locale is not None:
            oprot.writeFieldBegin('locale', TType.STRING, 1)
            oprot.writeString(self.locale.encode('utf-8') if sys.version_info[0] == 2 else self.locale)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getChannelNotificationSettings_args)
getChannelNotificationSettings_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'locale', 'UTF8', None, ),  # 1
)


class getChannelNotificationSettings_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype574, _size571) = iprot.readListBegin()
                    for _i575 in range(_size571):
                        _elem576 = ChannelNotificationSetting()
                        _elem576.read(iprot)
                        self.success.append(_elem576)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getChannelNotificationSettings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter577 in self.success:
                iter577.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getChannelNotificationSettings_result)
getChannelNotificationSettings_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [ChannelNotificationSetting, None], False), None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class updateChannelNotificationSetting_args(object):
    """
    Attributes:
     - setting

    """


    def __init__(self, setting=None,):
        self.setting = setting

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.setting = []
                    (_etype581, _size578) = iprot.readListBegin()
                    for _i582 in range(_size578):
                        _elem583 = ChannelNotificationSetting()
                        _elem583.read(iprot)
                        self.setting.append(_elem583)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateChannelNotificationSetting_args')
        if self.setting is not None:
            oprot.writeFieldBegin('setting', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.setting))
            for iter584 in self.setting:
                iter584.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateChannelNotificationSetting_args)
updateChannelNotificationSetting_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'setting', (TType.STRUCT, [ChannelNotificationSetting, None], False), None, ),  # 1
)


class updateChannelNotificationSetting_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateChannelNotificationSetting_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateChannelNotificationSetting_result)
updateChannelNotificationSetting_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class revokeChannel_args(object):
    """
    Attributes:
     - channelId

    """


    def __init__(self, channelId=None,):
        self.channelId = channelId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.channelId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeChannel_args')
        if self.channelId is not None:
            oprot.writeFieldBegin('channelId', TType.STRING, 1)
            oprot.writeString(self.channelId.encode('utf-8') if sys.version_info[0] == 2 else self.channelId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeChannel_args)
revokeChannel_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'channelId', 'UTF8', None, ),  # 1
)


class revokeChannel_result(object):
    """
    Attributes:
     - e

    """


    def __init__(self, e=None,):
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('revokeChannel_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(revokeChannel_result)
revokeChannel_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class getChannelSettings_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getChannelSettings_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getChannelSettings_args)
getChannelSettings_args.thrift_spec = (
)


class getChannelSettings_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ChannelSettings()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getChannelSettings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getChannelSettings_result)
getChannelSettings_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ChannelSettings, None], None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)


class updateChannelSettings_args(object):
    """
    Attributes:
     - channelSettings

    """


    def __init__(self, channelSettings=None,):
        self.channelSettings = channelSettings

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.channelSettings = ChannelSettings()
                    self.channelSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateChannelSettings_args')
        if self.channelSettings is not None:
            oprot.writeFieldBegin('channelSettings', TType.STRUCT, 1)
            self.channelSettings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateChannelSettings_args)
updateChannelSettings_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'channelSettings', [ChannelSettings, None], None, ),  # 1
)


class updateChannelSettings_result(object):
    """
    Attributes:
     - success
     - e

    """


    def __init__(self, success=None, e=None,):
        self.success = success
        self.e = e

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ChannelException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateChannelSettings_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateChannelSettings_result)
updateChannelSettings_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'e', [ChannelException, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs

